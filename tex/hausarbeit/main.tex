% Oliver Erxleben, Martin Helmich
% Hardwarenahe System und Treiberprogrammierung
%
% TODO: LibCIntelhex nach oben, vor libzpu? ?

\documentclass[11pt]{scrartcl}

% own geometry
%\usepackage[a4paper, left=3cm, right=3cm]{geometry}

\usepackage[ngerman]{babel} 
\usepackage[utf8]{inputenc} 
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{color}
\usepackage{xcolor}
\usepackage{jurabib}
\usepackage{hyperref}
\usepackage{tikz}
\usepackage{booktabs}
\usepackage{enumitem}

\include{lib/jurabib}
\bibliographystyle{jurabib}

% setup of source code listings
\usepackage{listings}
\usepackage{caption}
\lstset{
	basicstyle=\footnotesize\ttfamily,	% default font
	numbers=left,						% line numbers placement
	numberstyle=\tiny,					% line numbers style
	%stepnumber=2,						% line number padding
	numbersep=5pt,						% padding between line numbers and code
	tabsize=2,							% 
	extendedchars=true,         
	breaklines=true,						% line breaks 
	keywordstyle=\color{red},
	frame=lrtb,
	stringstyle=\color{gray}\ttfamily,	% color of strings in code
	showspaces=false,					% visualize spaces
    showtabs=false,						% visualize tabs
    xleftmargin=17pt,
	framexleftmargin=17pt,
	framexrightmargin=5pt,
	framexbottommargin=4pt,
	showstringspaces=false				% visualize spaces in strings        
}

\lstset{
  literate={ö}{{\"o}}1
           {ä}{{\"a}}1
           {ü}{{\"u}}1
}
 
\lstloadlanguages{% Check docs for further languages ...
	C,
	C++,
	bash
}

\setlength{\parindent}{0pt}
\setlength{\parskip}\medskipamount

\tikzstyle{every node}=[font=\footnotesize]

%\DeclareCaptionFont{white}{\color{white}}
%\DeclareCaptionFormat{listing}{\colorbox{gray}{\parbox{\textwidth}{#1#2#3}}}
%\captionsetup[lstlisting]{format=listing,labelfont=white,textfont=white}

% layout the box
%\DeclareCaptionFormat{listing}{\colorbox[rgb]{0.43, 0.35, 0.35 {\parbox{\textwidth}{\hspace{15pt}#1#2#3}}}

% layout the caption ontop of code
%\captionsetup[lstlisting]{format=listing,labelfont=white,textfont=white, singlelinecheck=false, margin=0pt, font={bf,footnotesize}}

% Headings
\usepackage{fancyhdr}
\fancyhead[R]{}
\fancyfoot{}

% Document begins now
\begin{document}

\author{%
	Martin Helmich \small(\href{mailto:martin.helmich@hs-osnabrueck.de}{martin.helmich@hs-osnabrueck.de})\\%
	Oliver Erxleben \small(\href{mailto:oliver.erxleben@hs-osnabrueck.de}{oliver.erxleben@hs-osnabrueck.de})\\ \\%
	%
	Hochschule Osnabr"uck \\%
	Ingenieurswissenschaften und Informatik \\%
	Informatik - Mobile und Verteilte Anwendungen }

\title{\includegraphics[scale=0.75,keepaspectratio]{images/hs_os.png}\linebreak \linebreak Entwicklung eines Treiber und einer Toolchain zur Administration eines Embedded Systems}
\subtitle{Am Beispiel einer ZPU unter Linux}

\maketitle
\thispagestyle{empty}
\pagebreak
\tableofcontents

\listoffigures

\lstlistoflistings

\thispagestyle{empty}
\pagebreak
\thispagestyle{empty}
\begin{abstract}
\textbf{Zusammenfassung:}\\ 	
Die vorliegende Arbeit wurde mit LaTeX verfasst und ist eine gemeinsame Arbeit von Oliver Erxleben und Martin Helmich für das Modul \textit{Hardwarenahe System- und Treiberprogrammierung} aus dem Master-Studiengang \textit{Informatik - Verteilte und Mobile Anwendungen} im Wintersemester 2012/13 an der Hochschule Osnabrück / University of Applied Sciences. \\
Das Thema der Arbeit lautet \textit{Entwicklung eines Treiber und einer Toolchain zur Administration eines Embedded Systems}. Im Kern beschreibt die Arbeit die Entwicklung eines Treibers für ein eingebettetes System unter Linux. Treiberprogrammierung unter anderen Systemen, wie zum Beispiel Microsoft Windows oder Apple Mac OS werden nicht betrachtet. Genauer wird zum einen ein Linux-Treiber für eine ZPU vorgestellt und zum anderen Bibliotheken und Wekrzeuge für die einfache Verwendung in Anwenderprogrammen zur Steuerung des ZPU entwickelt.\\
Im ersten Teil der Arbeit wird das Konzept der Hardware und das Konzept des Treibers und der Programmierbibliotheken vorgestellt. In den darauffolgenden Abschnitten werden detailliert die einzelnen Komponenten des Treibers beschrieben. Anwenderprogramme zum Testen werden an geeigneten Stellen vorgestellt.\\
Details über die Implementierung der Anwenderprogrammen wird aus Gründen der Lesbarkeit in den Anhang verschoben.\\
% TODO Kernel Version ???
Sofern nicht anders angegeben, wird zum Kompilieren des Quellcodes der GNU-Compiler GCC unter Linux (Kernel-Version 2.6.XX) verwendet. 
\end{abstract}

\pagebreak
% set new page style

\pagestyle{fancy}
\setcounter{page}{1} 

\section{Einleitung}

% TODO: überarbeiten / erweitern
Täglich verwendet und verlässt sich unsere Gesellschaft auf computergestützte Anwendungen. Wir suchen, schreiben, drucken, kopieren, erstellen oder entfernen Daten. Nur allzu oft werden dabei Geräte verwendet, die Funktionen für den Anwender bereitstellen, oder aber das Funktionsspektrum des Comutersystems erweitern. Funktionen der Computerkomponenten werden durch Anwenderprogramme durchgeführt, die von einem Betriebssystem verwaltet werden. Das Betriebssystem verwaltet auch alle Komponenten des Computersystems. Diese Komponenten sind Software oder auch Hardware. Erst die Teamarbeit zwischen Hardware und Software ermöglicht für den Anwender die Ausführung komplexer Programme.\\
\\
Das Betriebssystem steuert den Zugriff auf Hardware und benötigt Kenntnisse über die installierten Hardwarekomponenten. Das \textit{Wissen} über angeschlossene Hardwarekomponenten ist in sog. Gerätetreibern\footnote{Gerätetreiber: Softwaremodul, welches Zugriffe und Interaktionen mit installierter Hardware steuert.} hinterlegt. Es stellt einen Teil des Betriebssystemkerns dar, der für den Zugriff auf Hardware verantwortlich ist. Für jedes Gerät wird ein eigener Treiber benötigt \textit{(Vgl. siehe \cite{ltp_book}, Kapitel 1)}.\\
\\
Die Entwicklung eines Gerätetreibers und zugehörige Softwarekomponenten stellen einen interessanten, wenn nicht sogar erstrebenswerten, Teil der Programmierung von Computersystemen dar.

\pagebreak

\section{Architektur}
 
\subsection{ZPU}
Der ZPU ist nach Angaben des Herstellers, Zylin AS, der kleinste 32-Bit-Mikroprozessor der Welt und zählt zu der Kategorie der \textit{Soft CPU}\footnote{Soft-CPU:}s. Die grundlegende Idee, bzw. Aufgabe eines Soft-CPU, bzw. dem ZPU ist so wenig FPGA\footnote{FPGA: Field Programmable Gate Array}-Speicher wie möglich aufzunehmen und Arbeitslast dem HDL\footnote{HDL: Hardware Description Language}-Programm zu überlassen.

Zur Programmierung des ZPU kann die GCC-Toolchain verwendet werden. Neben \textit{GDB} werden \textit{newlib} und \textit{libstdc+} unterstützt.

Weiterhin ist es möglich den ZPU mit einem eingebetteten Betriebssystem zu betreiben. Das \textit{eCos}\footnote{eCos:}-Embbedded Operating System wird vom ZPU unterstützt. 

% TODO: PCI Board Beschreibung überarbeiten
Neben dem ZPU sind weitere Komponenten auf dem PCI-Board enthalten. Zum einen zwei Ein- und Ausgabe-Fifos, welche zum Laden des Programms für die ZPU genutzt werden und zum anderen eine 7-Segment-Anzeige. \\
Die Hardware-Architektur des ZPU lässt sich 

\begin{figure}[!htb]
	\begin{center}
		\includegraphics[width=0.9\textwidth]{images/zpu_architecture}
		\caption{Architektur der ZPU}
		\label{zpu_architecture}	
	\end{center}
\end{figure}

\begin{figure}[!htb]
	\begin{center}
		%include from external
		\include{snippets/zpuIO}
		\caption{ZPU-Ein und Ausgabe}
		\label{zpu_io}
	\end{center}
\end{figure}

\subsection{Überblick über die Treiber-Toolchain}
Wie in der Einleitung bereits beschrieben, sollen neben dem Treiber-Modul auch Bibliotheken für Benutzerprogramme, sowie Benutzerprogramme selbst entwickelt werden. Die Abbildung \ref{zpu_architecture} zeigt die drei Ebenen die entwickelt werden. Die Bibliotheken 

\begin{figure}[!htb]
	\begin{center}
		\include{snippets/archOverview}
		\caption{Überblick ZPU-Toolchain}
		\label{zpu_architecture}	
	\end{center}
\end{figure}

\section{Linux-Treiber-Modul: modzpu}
% TODO: verfassen
\subsection{Überblick über das Modul}
\subsection{Initialisieren des Moduls}
\subsection{MMAP}
\subsection{Read Write}
\subsection{IOCTRL}

\pagebreak
\section{Parsing der Intel HEX-Dateien: Die libcintelhex}
\label{chapter_libcintelhex}

Die Logik zum Parsen der Intel HEX-formatierten Eingabedateien wurde in eine eigene Programmbibliothek ausgegliedert. Der folgende Abschnitt beschreibt zunächst das Intel HEX-Datenformat, erläutert anschließend Installation und Schnittstellen der (im Rahmen dieser Arbeit entstandenen) cintelhex-Bibliothek und erklärt die dort verwendeten Algorithmen.

\subsection{Das Intel HEX-Format}

Bei dem \emph{INTEL Hexadecimal Object File Format} (kurz \emph{INTEL HEX}) handelt es sich um ein Dateiformat zur Codierung binärer Daten in ASCII-Dateien. Ursprünglich ausgelegt für 8-Bit-Intelprozessoren mit Adressräumen von 16 Bit, wurde das Format später erweitert für 16-Bit-Prozessoren mit 20-Bit-Adressräumen und für 32-Bit-Prozessoren.
\footnote{Vgl. \cite[S. 4]{intelhex}}

Der Aufbau eines Intel HEX-Datensatzes ist in Abbildung \ref{record_structure} dargestellt. Jeder Datensatz beginnt mit einem \emph{Record Mark} (ein \texttt{:}-Zeichen, oder \texttt{0x3A} in ASCII). Es folgen die Länge des Datensatzes (1 Byte, codiert in 2 ASCII-Zeichen), der Adress-Offset (2 Byte), der Typ des Datensatzes (1 Byte), der eigentliche Datensatz (variabel, bis zu 255 Bytes) und eine Prüfsumme (1 Byte), anhand derer die Korrektheit des Datensatzes überprüft werden kann.

\begin{figure}[h!]
\begin{center}
\begin{tabular}{cccccc}
	\toprule
	\texttt{:} & \texttt{10} & \texttt{0400} & \texttt{00} & \texttt{B0B0B98B02D0B0B0B88800400000000} & \texttt{29} \\ \midrule
	& Länge & Adresse & Typ & Daten & Prüfsumme \\ \bottomrule
\end{tabular}
\caption{Aufbau eines Intel HEX-Datensatzes}
\label{record_structure}
\end{center}
\end{figure}

Neben regulären Datensätzen (Typ \texttt{0x00}) und einem EOF-Datensatz (Typ \texttt{0x01}), der das Dateiende markiert, kennt die Spezifikation noch weitere Datensatz-Typen, die beispielsweise die Nutzung eines 20- oder 32-Bit-Adressraums ermöglichen. So kann beispielsweise ein spezieller \emph{Extended Linear Address Record} (Typ \texttt{0x04}) verwendet werden, um durch Angabe einer \emph{Upper Linear Base Address} den Adressraum auf 32 Bit zu erweitern.

Da der Speicher des verwendeten ZPU-Boards nur 8 KiB umfasst, ist eine Verwendung der 32-Bit-Funktionen nicht notwendig (16 Bit adressieren maximal $2^{16} = 64$ KiB). Aus diesem Grund bietet die cintelhex-Bibliothek nur experimentelle Unterstützung für 32-Bit-Adressen.

\begin{lstlisting}[caption=Beispiel einer Intel HEX-Eingabedatei]
:1000000000000000000000000000000000000000F0
:0400100000000000EC
:100400000B0B0B98B02D0B0B0B8880040000000029
:1004100000000000000000000000000000000000DC
// ...
:1010E200000008D9000008D9000008D9000008D97A
:1010F200000008D9000008D9000008D9000008D96A
:0C110200000008D9000008D9000008D93E
:0400000300000400F5
:00000001FF
\end{lstlisting}

\subsection{Installation}

Die Installation der cintelhex-Bibliothek erfolgt mit den Unix-üblichen \texttt{configure}- und \texttt{make}-Befehlen. Außer dem Build-Tool \texttt{make}, der C-Standardbibliothek und dem GCC werden keine Abhängigkeiten benötigt.

\begin{lstlisting}[caption=Installation der cintelhex-Bibliothek]
> ./configure # optional: --prefix=/usr/local
> make
> make install
> ldconfig
\end{lstlisting}

Bei der Installation wird die Datei \texttt{libcintelhex.so} nach \texttt{<prefix>/lib}, und die Datei \texttt{cintelhex.h} nach \texttt{<prefix>/include} installiert. Das Standardpräfix ist \texttt{/usr/local}.

Bei Verwendung des Standardpräfix kann die cintelhex-Bibliothek beim Linken durch den GCC-Parameter \texttt{-l cintelhex} aktiviert werden.

\subsection{Schnittstellenbeschreibung}

Die Methoden der cintelhex-Bibliothek können durch inkludieren der Header-Datei \texttt{cintelhex.h} verwendet werden. In der Datei werden folgende wichtigen Methoden deklariert:

\begin{description}[style=unboxed]
	\item[ihex\_recordset\_t* ihex\_rs\_from\_file(char* filename)] Diese Methode liest den Inhalt einer Intel HEX-Datei (der Dateiname wird durch \texttt{filename} beschrieben) in eine \texttt{ihex\_recordset\_t}-Struktur (siehe auch Abschnitt \ref{ihex_structs}). Sie liefert einen Zeiger auf die ausgelesene Struktur zurück, oder \texttt{NULL} im Fehlerfall.
	\item[ihex\_recordset\_t* ihex\_rs\_from\_string(char* data)] Diese Methode verhält sich genau wie \texttt{ihex\_rs\_from\_file}, erwartet als Eingabeparameter jedoch direkt einen Zeiger auf einen Intel HEX-String.
	\item[int ihex\_mem\_copy(ihex\_recordset\_t *rs, void* dst, ulong\_t n, ihex\_width\_t w, ihex\_byteorder\_t o)] Diese Methode kopiert das durch eine Intel HEX-Datei beschriebene Programm an eine beliebige Stelle im Speicher. Das zu ladende Programm wird durch die Struktur \texttt{rs} beschrieben. Der Zeiger \texttt{dst} beschreibt die Zielposition im Speicher (dies kann auch ein durch \texttt{mmap} abgebildeter Gerätespeicher sein). \texttt{n} beschreibt die Größe des Zielbereichs. Die Methode liefert im Erfolgsfall 0, ansonsten einen Fehlercode zurück.
	\item[char* ihex\_error()] Diese Methode liefert eine Beschreibung des zuletzt aufgetretenen Fehlers zurück. Falls kein Fehler aufgetreten ist, wird \texttt{NULL} zurückgeliefert.
	\item[ihex\_error\_t ihex\_errno()] Diese Methode liefert den Fehlercode des zuletzt aufgetretenen Fehlers zurück. Falls kein Fehler aufgetreten ist, wird \texttt{0} zurückgeliefert.
\end{description}

\subsection{Datenstrukturen}
\label{ihex_structs}

Die cintelhex-Bibliothek definiert die beiden Datenstrukturen \texttt{ihex\_recordset\_t} und \texttt{ihex\_record\_t}. Sie sind wie folgt definiert:

\begin{lstlisting}[language=C,morekeywords={uint\_t, ihex\_rtype\_t, ihex\_addr\_t, ihex\_rdata\_t, ihex\_rchks\_t, ihex\_record\_t, ihex\_recordset\_t}, caption=Definition der \texttt{ihex\_record\_t}- und \texttt{ihex\_recordset\_t}-Strukturen]
/// Models a single Intel HEX record.
typedef struct ihex_record {
	uint_t       ihr_length;   //!< Length of the record in bytes.
	ihex_rtype_t ihr_type;     //!< Record type (see ihex_rtype_t).
	ihex_addr_t  ihr_address;  //!< Base address offset.
	ihex_rdata_t ihr_data;     //!< Record data.
	ihex_rchks_t ihr_checksum; //!< The record's checksum.
} ihex_record_t;

/// Models a set of Intel HEX records.
typedef struct ihex_recordset {
	uint_t         ihrs_count;   //!< Amount of records.
	ihex_record_t *ihrs_records; //!< A list of record (with ihrs_count elements).
} ihex_recordset_t;
\end{lstlisting}

Abbildung \ref{lcih_datastructs} zeigt zudem die Beziehungen der Datenstrukturen untereinander. Das Attribut \texttt{ihex\_data} der Struktur \texttt{ihex\_record\_t} ist ein Zeiger auf ein \texttt{uint8\_t}-Feld der Länge \texttt{ihr\_length}.

\begin{figure}[!htb]
	%include from externl
	\begin{center}
		\include{snippets/libcintelhex_datastructs}
	\end{center}
	\caption{Datenstrukturen der libcintelhex}
	\label{lcih_datastructs}
\end{figure}

\subsection{Fehlercodes}

Die \texttt{cintelhex.h} definiert die folgenden Fehlerkonstanten:

\begin{description}
	\item[IHEX\_ERR\_INCORRECT\_CHECKSUM] Tritt auf, wenn die Prüfsumme eines Eintrages ungültig ist. Zur Verifizierung der Prüfsumme werden alle Bytes eines Eintrages (einschließlich der Prüfsumme selbst) aufsummiert. Ist das unterste Byte der Summe $=0$, ist die Prüfsumme korrekt.
	\item[IHEX\_ERR\_NO\_EOF] Tritt auf, wenn die Eingabedatei keinen EOF-Eintrag (Typ \texttt{0x01}) enthält.
	\item[IHEX\_ERR\_PARSE\_ERROR] Tritt auf, wenn die Eingabedatei ungültig formatiert ist (etwa bei Fehlen des Record Marks (\texttt{:})).
	\item[IHEX\_ERR\_WRONG\_RECORD\_LENGTH] Tritt auf, wenn die tatsächliche Länge eines Datensatzes nicht der im ersten Byte angegebenen entspricht.
	\item[IHEX\_ERR\_NO\_INPUT] Tritt auf, wenn die Eingabedatei nicht existiert, oder nicht geöffnet werden konnte.
	\item[IHEX\_ERR\_UNKNOWN\_RECORD\_TYPE] Tritt auf, wenn ein Datensatz eine ungültige Typ-Bezeichnung (Byte 4) hat).
	\item[IHEX\_ERR\_PREMATURE\_EOF] Tritt auf, wenn der EOF-Datensatz (Typ \texttt{0x01}) in einer anderen Zeile als der letzten auftritt.
	\item[IHEX\_ERR\_ADDRESS\_OUT\_OF\_RANGE] Tritt auf, wenn an eine ungültige Adresse geschrieben werden soll.
	\item[IHEX\_ERR\_MMAP\_FAILED] Tritt auf, wenn eine Eingabedatei nicht in den Speicher gemappt werden konnte.
\end{description}

\subsection{Anwendungsbeispiel}

Listing \ref{cintelhex-example} zeigt ein einfaches Anwendungsbeispiel der cintelhex-Bibliothek. Der Einfachheit halber zeigt die Variable \texttt{d} hier nur auf einen dynamisch alloziierten Speicherbereich, könnte jedoch auch ebenso gut auf den per \texttt{mmap} abgebildeten Speicher des ZPU-Boards zeigen.

\begin{lstlisting}[language=C,caption=Anwendungsbeispiel der cintelhex-Bibliothek,label=cintelhex-example]
#include <stdlib.h>
#include <cintelhex.h>

int main()
{
	ihex_recordset_t* r = ihex_rs_from_file("input.hex");
	void*             d = malloc(8192);
	
	if (r != NULL)
	{
		return ihex_mem_copy(r, d, 8192, IHEX_WIDTH_32BIT, IHEX_ORDER_BIGENDIAN);
	}
	return ihex_errno();
}
\end{lstlisting}

\subsection{Besonderheiten der Umsetzung}

%\subsubsection{8- vs. 32-Bit-Zugriff}

Erste Versionen der cintelhex-Bibliothek versuchten, den Zielspeicherbereits byteweise zu befüllen. Während dies bei Tests an dynamisch alloziiertem RAM kein Problem darstellte, wurde schnell deutlich, dass diese Art des Zugriffs bei dem Speicher des ZPU-Boards nicht funktioniert. Listings \ref{zpu_mem_8bit} und \ref{zpu_mem_32bit} verdeutlichen das Problem.

\begin{lstlisting}[float=p,language=C,caption=Unerwartetes Verhalten des ZPU-Speichers bei 8-Bit-Zugriff,morekeywords={uint8_t,uint32_t},label=zpu_mem_8bit]
uint8_t *d; // d zeigt auf den gemappten Geraetespeicher

d[0x00] = 0x0b;
printf("%02x \n", d[0x00]); // Gibt "0b" aus (korrekt).

d[0x01] = 0x98;
printf("%02x \n", d[0x00]); // Gibt "00" aus (sollte immer noch "0b" sein)!
printf("%02x \n", d[0x01]); // Gibt "98" aus (korrekt).
\end{lstlisting}

\begin{lstlisting}[float=p,language=C,caption=Korrektes Verhalten des ZPU-Speichers bei 32-Bit-Zugriff,morekeywords={uint8_t,uint32_t},label=zpu_mem_32bit]
uint8_t *d; // d zeigt auf den gemappten Geraetespeicher

*((uint32_t*) d) = 0x0000980b;

printf("%02x \n", d[0x00]); // Gibt "0b" aus (korrekt).
printf("%02x \n", d[0x01]); // Gibt "98" aus (korrekt).
\end{lstlisting}

Weiterhin fiel auf, dass das geladene Programm von der ZPU nur dann korrekt ausgeführt werden konnte, wenn die Intel HEX-Daten als 32-Bit-Blöcke in \emph{Big Endian}-Reihenfolge interpretiert wurden. Abbildung  \ref{zpu_addresses} verdeutlicht diesen Zusammenhang.

Die cintelhex-Bibliothek berücksichtigt diesen Zusammenhang. So akzeptiert die Methode \texttt{ihex\_mem\_copy} einen Parameter \texttt{w}, über welchen die Wortbreite angegeben werden kann, sowie einen Parameter \texttt{o}, welcher die Byte-Reihenfolge beschreibt. Listing \ref{ihex_copy_algo} beschreibt den Algorithmus zum Laden eines Intel HEX-Datensatzes in den ZPU-Speicher.

\begin{figure}
\begin{center}
\begin{tabular}{lrrrrrrrrc}
	\toprule
	Daten   &  0B &  0B &  0B &  98 &  B0 &  2D &  0B &  0B & $\ldots$ \\ \midrule
	Adresse & 403 & 402 & 401 & 400 & 407 & 406 & 405 & 404 & $\ldots$ \\ \bottomrule
\end{tabular}
\end{center}
\caption{Übersetzung von Binärdaten in lauffähige ZPU-Programme.}
\label{zpu_addresses}
\end{figure}

\begin{lstlisting}[float=p,language=C,caption=Algorithmus zum Laden eines Intel HEX-Datensatzes in den ZPU-Speicher,morekeywords={uint8_t, uint32_t, ihex_width_t, ihex_record_t, ihex_byteorder_t},label=ihex_copy_algo]
ihex_width_t     w = IHEX_WIDTH_32BIT;     //<! Wortbreite in Byte
ihex_byteorder_t o = IHEX_ORDER_BIGENDIAN; //<! Byte-Reihenfolge
uint8_t          j, l;                     //<! Laufvariablen
ihex_record_t   *x;                        //<! Ein IHEX-Datensatz

for (j = 0; j < x->ihr_length; j += w)
{
	uint32_t  v      = 0;
	uint32_t *target = (uint32_t*) (d + address + j);
					
	for (l = 0; (l < w) && (j + l < x->ihr_length); l ++)
	{
		v += x->ihr_data[j+l] << (8 * ((o == IHEX_ORDER_BIGENDIAN) ? ((w - 1) - l) : l));
	}
	*(target) = v;
}
\end{lstlisting}

\pagebreak
\section{Programmierung der ZPU: Die libzpu}
\label{chapter_libzpu}

% TODO: erweitern
Die \textit{libzpu} stellt die für Anwenderprogramme benötigten Funktionen des Treibers zur Verfügung. Die Schnittstelle wurde zur Abstrahierung der Logik für Anwenderprogramme erstellt. Dieser Abschnitt beschreibt die Bibliotheksfunktionen und zeigt exemplarisch wie die Bibliothek in Anwenderprogrammen genutzt werden kann. \\
\\
Die Quelltexte für die Bibliothek finden sich auf der beigelegten CD oder aber auf Github: \url{https://github.com/olivererxleben/zpulib}. 

\subsection{Installation}
Um die Bibliothek auf einem Linux-System zu installieren muss in das Wurzelverzeichnis der Quellen gewechselt werden und dort über ein Unix-übliches Makefile ausgeführt werden.\\

\begin{lstlisting}[caption=Installation der zpulib-Bibliothek]
# in directory
> ./configure
> make
> make install
\end{lstlisting}
 
\subsection{Bibliotheksfunktionen}
Die Methoden der libzpu können durch Einbindung der \texttt{zpu.h} in ein Anwenderprogramm benutzt werden. Desweiteren existiert die \texttt{zpu\_commands.h}, in der die IO-Kontrolle für die ZPU implementiert ist. \\
Die \textit{zpulib} benutzt zudem Funktionen der \textit{libcintelhex} um Hex-Dateien zu laden. 
\\
Das Listing \ref{zpulibfuncs} zeigt einen Auszug mit den Funktionsköpfen der \textit{zpu.h}. \\
% TODO: Beschreibung, Zeilen anpassen
\begin{lstlisting}[language=C, firstnumber=44, label=zpulibfuncs, caption=zpulib-Bibliotheksfunktionen][h!]

/// Load an Intel HEX formatted program into the ZPU
/** This method loads a new program into the ZPU. The input file needs
 *  to be an Intel HEX formatted binary.
 *  Before loading the program, the ZPU is set into "reset" mode. After
 *  that, the new program is parsed and copied into the ZPU's ROM and
 *  the ZPU is set back into regular mode.
 *  @param filename The filename of the input Intel HEX file.
 *  @return         ZPU_ERR_OK on success, otherwise an error code. */
zpu_error_t zpu_load_from_file(char* filename);

/// Halt the ZPU.
/** This method sets the ZPU into "reset" mode.
 *  @return ZPU_ERR_OK on success, otherwise an error code. */
int zpu_stop();

/// Start the ZPU, if halted.
/** This method sets the ZPU back into regular mode, if it was stopped
 *  earlier. 
 *  @return ZPU_ERR_OK on success, otherwise an error code. */
int zpu_start();

\end{lstlisting}

% TODO: zpuload vorstellen 
\subsubsection{Dateien Laden}

\subsubsection{ZPU Starten und Stoppen}

\subsubsection{}

%\subsection{Python-Bindings}

\pagebreak
\section{Anwenderprogramme}

Zur Steuerung des ZPU-Boards wurden schließlich die Werkzeuge \emph{zpuload}   und \emph{zpuio} entwickelt. Das Paket liegt dieser Arbeit auf Datenträger bei, und befindet sich im Verzeichnis \texttt{apps/zputools}.

\subsection{Installation}

\emph{zpuload} und \emph{zpuio} gehören beide zum \emph{zputools}-Paket, können also gemeinsam installiert werden. Wie bei den anderen im Rahmen dieser Arbeit entstandenen Pakete, reicht auch hier der übliche Dreizeiler zur Installation aus:

\begin{lstlisting}[caption=Installation der zputools-Werkzeuge]
> ./configure # optional mit --prefix=...
> make
> make install
\end{lstlisting}

Bei der Installation werden die ausführbaren Programme \emph{zpuload} und \emph{zpuio} (abhängig vom prefix) nach \texttt{/usr/local/bin} kopiert.

Die \emph{zputools} benötigen einen GCC, die C-Standardbibliothek, sowie eine installierte cintelhex-Bibliothek (siehe Abschnitt \ref{chapter_libcintelhex}) und eine installierte zpu-Bibliothek (siehe Abschnitt \ref{chapter_libzpu}). Das \emph{configure}-Skript überprüft diese Abhängigkeiten automatisch.

\subsection{Programme laden mit zpuload}

Das \emph{zpuload}-Programm verwendet die Funktionen der \emph{cintelhex}- und \emph{zpu}-Bibliotheken, um ein neues Programm in den ZPU-Prozessor zu laden.

Hierzu wird per \texttt{zpu\_load\_from\_file(file)}-Methode ein neues Programm in den RAM der ZPU geladen (diese Methode versetzt die ZPU zuvor implizit in des Reset-Modus und startet sie anschließend wieder).

\begin{lstlisting}[caption=Verwendung des zpuload-Werkzeugs]
> /usr/local/bin/zpuload input.hex
Loading program from "input.hex"...
Loaded program.
\end{lstlisting}

\subsection{Ein- und Ausgabe mit zpuio}

Das \emph{zpuio}-Werkzeug dient dazu, Ein- und Ausgaben an den ZPU-Prozessor zu übermitteln. Dieses Programm ist vor allem als interaktive Schnittstelle gedacht.

\begin{lstlisting}[caption=Verwendung des zpuio-Werkzeugs]
> /usr/local/bin/zpuio
output (11) > Hello World
input > abcd
output (4) > Abcd
input >
\end{lstlisting}

Neben der Verwendung des \emph{zpuio}-Werkzeugs kann auch direkt in/aus der Gerätedatei \emph{/dev/zpu} geschrieben und gelesen werden.

\pagebreak
\section{Fazit}

\pagebreak % content ends here

\fancyhead[R]{}

\thispagestyle{empty}

\renewcommand*{\biburlprefix}{(URL: }
\renewcommand*{\biburlsuffix}{)}

\pagebreak
\addcontentsline{toc}{section}{Literaturverzeichnis} % Eintrag ins Inhaltsverzeichnis
\bibliography{bib/bib}

\appendix

\end{document}
