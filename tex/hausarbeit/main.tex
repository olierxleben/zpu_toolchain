% Oliver Erxleben, Martin Helmich
% Hardwarenahe System und Treiberprogrammierung
%
\documentclass[11pt]{scrartcl}

% own geometry
%\usepackage[a4paper, left=3cm, right=3cm]{geometry}

\usepackage[ngerman]{babel} 
\usepackage[utf8]{inputenc} 
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{color}
\usepackage{xcolor}
\usepackage{jurabib}
\usepackage{hyperref}
\usepackage{tikz}
\usepackage{booktabs}
\usepackage{enumitem}
\usepackage{here} % picture positioning


\include{lib/jurabib}
\bibliographystyle{jurabib}

% setup of source code listings
\usepackage{listings}
\usepackage{caption}
\lstset{
	basicstyle=\footnotesize\ttfamily,	% default font
	numbers=left,						% line numbers placement
	numberstyle=\tiny,					% line numbers style
	%stepnumber=2,						% line number padding
	numbersep=5pt,						% padding between line numbers and code
	tabsize=2,							% 
	extendedchars=true,         
	breaklines=true,						% line breaks 
	keywordstyle=\color{red},
	frame=lrtb,
	stringstyle=\color{gray}\ttfamily,	% color of strings in code
	showspaces=false,					% visualize spaces
    showtabs=false,						% visualize tabs
    xleftmargin=17pt,
	framexleftmargin=17pt,
	framexrightmargin=5pt,
	framexbottommargin=4pt,
	showstringspaces=false				% visualize spaces in strings        
}

\lstset{
  literate={ö}{{\"o}}1
           {ä}{{\"a}}1
           {ü}{{\"u}}1
}
 
\lstloadlanguages{% Check docs for further languages ...
	C,
	C++,
	bash
}

% Directory Tree settings 
\makeatletter
\newcount\dirtree@lvl
\newcount\dirtree@plvl
\newcount\dirtree@clvl
\def\dirtree@growth{%
  \ifnum\tikznumberofcurrentchild=1\relax
  \global\advance\dirtree@plvl by 1
  \expandafter\xdef\csname dirtree@p@\the\dirtree@plvl\endcsname{\the\dirtree@lvl}
  \fi
  \global\advance\dirtree@lvl by 1\relax
  \dirtree@clvl=\dirtree@lvl
  \advance\dirtree@clvl by -\csname dirtree@p@\the\dirtree@plvl\endcsname
  \pgf@xa=0.5cm\relax
  \pgf@ya=-0.5cm\relax
  \pgf@ya=\dirtree@clvl\pgf@ya
  \pgftransformshift{\pgfqpoint{\the\pgf@xa}{\the\pgf@ya}}%
  \ifnum\tikznumberofcurrentchild=\tikznumberofchildren
  \global\advance\dirtree@plvl by -1
  \fi
}

\tikzset{
  dirtree/.style={
    growth function=\dirtree@growth,
    every node/.style={anchor=north},
    every child node/.style={anchor=west},
    edge from parent path={(\tikzparentnode\tikzparentanchor) |- (\tikzchildnode\tikzchildanchor)}
  }
}

\makeatother

\setlength{\parindent}{0pt}
\setlength{\parskip}\medskipamount

\tikzstyle{every node}=[font=\footnotesize]

%\DeclareCaptionFont{white}{\color{white}}
%\DeclareCaptionFormat{listing}{\colorbox{gray}{\parbox{\textwidth}{#1#2#3}}}
%\captionsetup[lstlisting]{format=listing,labelfont=white,textfont=white}

% layout the box
%\DeclareCaptionFormat{listing}{\colorbox[rgb]{0.43, 0.35, 0.35 {\parbox{\textwidth}{\hspace{15pt}#1#2#3}}}

% layout the caption ontop of code
%\captionsetup[lstlisting]{format=listing,labelfont=white,textfont=white, singlelinecheck=false, margin=0pt, font={bf,footnotesize}}

% Headings
\usepackage{fancyhdr}
\fancyhead[R]{}
\fancyfoot{}

% Document begins now
\begin{document}

\author{%
	Martin Helmich \small(\href{mailto:martin.helmich@hs-osnabrueck.de}{martin.helmich@hs-osnabrueck.de})\\%
	Oliver Erxleben \small(\href{mailto:oliver.erxleben@hs-osnabrueck.de}{oliver.erxleben@hs-osnabrueck.de})\\ \\%
	%
	Hochschule Osnabr"uck \\%
	Ingenieurswissenschaften und Informatik \\%
	Informatik - Mobile und Verteilte Anwendungen }

\title{\includegraphics[scale=0.75,keepaspectratio]{images/hs_os.png}\linebreak \linebreak Entwicklung eines Treibers und einer Toolchain zur Administration eines Embedded Systems}
\subtitle{Am Beispiel einer ZPU unter Linux}

\maketitle
\thispagestyle{empty}
\pagebreak
\tableofcontents
\thispagestyle{empty}
\listoffigures

\lstlistoflistings

\thispagestyle{empty}
\pagebreak
\thispagestyle{empty}
\begin{abstract}
\textbf{Zusammenfassung:}\\ 	
Die vorliegende Arbeit wurde mit LaTeX verfasst und ist eine gemeinsame Arbeit von Oliver Erxleben und Martin Helmich für das Modul \textit{Hardwarenahe System- und Treiberprogrammierung} aus dem Master-Studiengang \textit{Informatik - Verteilte und Mobile Anwendungen} im Wintersemester 2012/13 an der Hochschule Osnabrück / University of Applied Sciences.


Das Thema der Arbeit lautet \textit{Entwicklung eines Treibers und einer Toolchain zur Administration eines Embedded Systems}. Im Kern beschreibt die Arbeit die Entwicklung eines Treibers für ein eingebettetes System unter Linux. Treiberprogrammierung unter anderen Systemen, wie zum Beispiel Microsoft Windows oder Apple Mac OS werden nicht betrachtet. Genauer wird zum einen ein Linux-Treiber für eine ZPU vorgestellt. Zum anderen werden Bibliotheken und Werkzeuge zur Verwendung in Anwenderprogrammen und zur Steuerung der ZPU beschrieben.


Im ersten Teil der Arbeit wird das Konzept der Hardware und das Konzept des Treibers und der Programmierbibliotheken vorgestellt. In den darauffolgenden Abschnitten werden detailliert die einzelnen Komponenten des Treibers beschrieben.


Die Anwenderprogramme zum Testen werden in einem eigenen Abschnitt vorgestellt, jedoch an geeigneten Stellen wird auf die Testprogramme verwiesen.
Sofern nicht anders angegeben, wird zum Kompilieren des Quellcodes der GNU-Compiler GCC unter Linux (Kernel-Version 2.6.XX) verwendet. 
\end{abstract}

\pagebreak
% set new page style

\pagestyle{fancy}
\setcounter{page}{1} 

\section{Einleitung}

\subsection{Motivation}

Täglich verwendet und verlässt sich unsere Gesellschaft auf computergestützte Anwendungen. Wir suchen, schreiben, drucken, kopieren, erstellen oder entfernen Daten. Nur allzu oft werden dabei Geräte verwendet, die Funktionen für den Anwender bereitstellen, oder aber das Funktionsspektrum des Comutersystems erweitern. Funktionen der Computerkomponenten werden durch Anwenderprogramme durchgeführt, die von einem Betriebssystem verwaltet werden. Das Betriebssystem verwaltet auch alle Komponenten des Computersystems. Diese Komponenten sind Software oder auch Hardware. Erst die Teamarbeit zwischen Hardware und Software ermöglicht für den Anwender die Ausführung komplexer Programme.

Das Betriebssystem steuert den Zugriff auf Hardware und benötigt Kenntnisse über die installierten Hardwarekomponenten. Das \textit{Wissen} über angeschlossene Hardwarekomponenten ist in sog. Gerätetreibern\footnote{Gerätetreiber: Softwaremodul, welches Zugriffe und Interaktionen mit installierter Hardware steuert.} hinterlegt. Es stellt einen Teil des Betriebssystemkerns dar, der für den Zugriff auf Hardware verantwortlich ist. Für jedes Gerät wird ein eigener Treiber benötigt.\footnote{Vgl. \cite{ltp_book}, Kapitel 1.}

Die Entwicklung eines Gerätetreibers und zugehörige Softwarekomponenten stellen einen interessanten, wenn nicht sogar erstrebenswerten, Teil der Programmierung von Computersystemen dar. 

\subsection{Aufgabenstellung}

Diese Arbeit behandelt die Entwicklung eines Linux-Treibers für ein PCI-Board mit eingebettetem ZPU-Prozessor. An den im Rahmen dieser Arbeit zu entwickelnden Treiber werden die folgenden Anforderungen gestellt:

\begin{itemize}
	\item{IOCTL/MMAP: Es soll möglich sein das eingebettete Prozessorsystem durch ein Applikationsprogramm zurückzusetzen und mit neuer Software zu laden.}
	\item{Read-/Write-Funktionen: Im Betrieb des eingebetteten Prozessorsystems soll es möglich sein über Anwenderprogramme Eingaben von der Standardeingabe zu senden und Ausgaben von der Standardausgabe zu lesen.}
	\item{Entwicklung geeigneter Anwenderprogramme zum Test des Treibers.}
\end{itemize}

\pagebreak

\section{Architektur}
 
\subsection{ZPU}

Der ZPU ist nach Angaben des Herstellers, Zylin AS, der kleinste 32-Bit-Mikroprozessor der Welt und zählt zu der Kategorie der \textit{Soft CPU}\footnote{Soft-CPU: Nicht fest platziert, befindet sich in einem FPGA (Vgl. siehe \cite{soft_cpu})}s. Die grundlegende Idee, bzw. Aufgabe einer Soft-CPU, bzw. der ZPU ist so wenig FPGA\footnote{FPGA: Field Programmable Gate Array}-Speicher wie möglich aufzunehmen und Berechnungen dem HDL\footnote{HDL: Hardware Description Language}-Programm zu überlassen.

Zur Programmierung der ZPU kann die GCC-Toolchain verwendet werden. Neben \textit{GDB} werden \textit{newlib} und \textit{libstdc+} unterstützt.

Weiterhin ist es möglich den ZPU mit einem eingebetteten Betriebssystem zu betreiben. Das \textit{eCos}\footnote{eCos: Real-time OS for embedded Applications (weitere Informationen, siehe \cite{wp_eCos}}-Embbedded Operating System wird vom ZPU unterstützt. 

Neben dem ZPU sind weitere Komponenten auf dem PCI-Board enthalten. Zum einen zwei Ein- und Ausgabe-Fifos, welche zum Laden des Programms für die ZPU genutzt werden und zum anderen eine 7-Segment-Anzeige.

Die Hardware-Architektur der ZPU lässt sich in Abbildung \ref{zpu_architecture} veranschaulichen. Das Prozessorsystem besteht aus dem ZPU-Prozessor, RAM- und ROM-Speicher und zwei FIFOs aus 8-Bit-Zeichen. 
Die Ein- und Ausgabe von Daten lassen sich über das Sende- und Empfangs-Fifo steuern. Zu beachten ist an dieser Stelle das die Fifos nach dem Ausgangspunkt (ZPU oder Linux-Kernel) zum Empfangen oder Senden genutzt werden. Aus Sicht der ZPU werden Daten gesendet wenn diese im Empfangs-Fifo des Kernels geschrieben werden. Empfangen werden Daten vom Kernel wenn diese in das Sende-Fifo geschrieben werden. 

Das Prozessorsystem kann über den PCI-Bus (und den darüber gesteuerten Wishbone-Bus) unterschiedlich angesprochen werden.

\begin{itemize}
    \item{Über ein Kontrollregister kann das Prozessorsystem zurückgesetzt werden.}
    \item{Der ROM- und der RAM-Speicher sind als Dual-Port-Speicher ausgeführt. Ein Port ist an die ZPU angeschlossen, über den zweiten Port kann durch den PCI-Bus auf die Speicher zugegriffen werden. Der ROM-Speicher ist dabei nur aus Sicht der ZPU ein reiner Lesespeicher. Aus Sicht des PCI-Busses kann der Speicher geschrieben und gelesen werden.}
    \item{Das Sende-Fifo des Prozessorsystems kann mittels Interrupt gelesen und das Empfangs-Fifo mittels Interrupt geschrieben werden. Ein Interrupt-Controller schaltet die beiden Interrupts auf das gemeinsame PCI-Interrupt-Signal.}

\end{itemize}

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.9\textwidth]{images/zpu_architecture}
		\caption{Architektur der ZPU}
		\label{zpu_architecture}	
	\end{center}
\end{figure}

Auf der Hardware befinden sich verschiedene Register, zum Beispiel um die ZPU zu kontrollieren. Die Abbildung \ref{zpu_registers} visualisiert die verschiedenen Register.

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=1\textwidth]{images/registers}
		\caption{Register der ZPU}
		\label{zpu_registers}	
	\end{center}
\end{figure}

\begin{description}

    \item[0x00002000 SYSCTL]
    Solange RST=1 ist, wird das eingebettete System im \textit{reset}-Modus gehalten. Wenn RST=0, wird der normale Betriebszustand ausgeführt, d. h. das Programm wird ausgeführt.
    
     \item[0x00002018 DATA]
     Das Datenregister: Daten für die ZPU-Standardeingabe werden hier geschrieben. Daten der ZPU-Standardausgabe können hier ebenfalls gelesen werden. Ein lesender Zugriff blockiert das Empfangs-FIFO, sollte es leer sein und ein schreibender Zugriff blockiert das Sende-FIFO, sollte es voll sein.  
    
    \item[0x00002014 CONTROL]
    Das Kontrollregister \texttt{RxIE} kann aktiviert werden um einen Interrupt beim Empfangs-FIFO auszulösen, sollte dieses nicht leer sein. Bei Aktivierung des Kontrollregisters \texttt{TxIE} wird ein Interrupt beim Sende-FIFO ausgelöst, sollte es nicht voll sein. 
    
    \item[0x00002018 STATUS]
    Das Register \texttt{RxInt} zeigt an, dass ein Empfangs-Interrupt angefordert wird. Status wird durch eine AND-Verknüpfung von \texttt{RxV} und \texttt{RxIE} gesetzt. \texttt{TxInt} zeigt an das ein Sende-Interrupt angefordert wird. Es wird gesetzt durch AND-Verknüpfung von \texttt{TxE} und \texttt{TxIE}. Bei \texttt{RxV} handelt es sich um die Anzeige, dass das Empfangs-FIFO nicht leer ist. Lesen aus dem Datenregister ist möglich. \texttt{TxE} zeigt an, dass das Sende-FIFO nicht voll ist und ein Schreiben in das Datenregister möglich ist.
 
\end{description}

\subsection{Überblick über die Treiber-Toolchain}
Wie in der Einleitung bereits beschrieben, sollen neben dem Treiber-Modul auch Bibliotheken für Benutzerprogramme, sowie Benutzerprogramme selbst entwickelt werden. Die Abbildung \ref{zpu_overview} zeigt die drei Ebenen die entwickelt werden.

\begin{figure}
	\begin{center}
		\include{snippets/archOverview}
		\caption{Überblick ZPU-Toolchain}
		\label{zpu_overview}	
	\end{center}
\end{figure}

\pagebreak
\section{Linux-Treibermodul: modzpu}

Der Treiber für das Embedded System stellt die zentrale Steuerungssoftware für das Hostsystem und den Treiber dar. Dieser Abschnitt gibt einen Überblick über das Treibermodul und stellt die wichtigsten Funktionen im Modul vor. Zur Übersichtlichkeit wurden Funktionen für den PCI-Treiber in mehrere Dateien aufgesplittet. Das Treibermodul ist wie folgt aufgebaut:

\begin{figure}[H]
\begin{center}
\frame{\begin{tikzpicture}[dirtree]
\node{module} 
    child { node {scripts}
            child { node {load.sh} }
            child { node {unload.sh} }
    }
    child { node {zpu\_commands.h} }
    child { node {modzpu.h} }
    child { node {modzpu.c} }
    child { node {fifo.c} }
    child { node {zpu\_io.c} }
    child { node {zpu\_irq.c} }
    child { node {zpu\_mem.c} }
    child { node {zpu\_open.c} }
    child { node {Makefile} }
    
    ; % finish nodes

\end{tikzpicture}}
\end{center}
\caption{Dateien des ZPU-Kernelmoduls.}
\end{figure}


\subsection{Installation}

Das Treibermodul lässt sich einfach über ein Makefile installieren, bzw. deinstallieren. Es befindet sich im Wurzelverzeichnis des Treibermoduls und benötigt die sich im Unterverzeichnis  \textit{scripts} befindenen Bash-Skripte \textit{load.sh} und \textit{unload.sh}. Die Bash-Skripte sind für das Laden und Entladen des Treibermoduls aus dem Kernel verantwortlich.
Das Listing \ref{modzpu_install} zeigt die bequeme Installation des Treibers. Anzumerken ist, dass der Eingriff in den Kernel und das Laden/Entladen des Moduls in den Kernel, bzw. aus dem Kernel, root-Rechte am Sytem benötigt. Äquivalent zum Listing \ref{modzpu_install} kann das Modul mittels \texttt{make uninstall} wieder entladen werden. 

\begin{lstlisting}[label=modzpu_install,language=bash, caption=Installation des Treibermoduls][!h]
> cd to/the/module/folder
> su # optional, if not root
> make
> make install
\end{lstlisting}

\subsection{Schnittstellen}

\subsubsection{Funktionen}

Das Treibermodul stellt alle wichtigen Funktionen für die Hardware zur Verfügung. Dies sind neben den Basisfunktionen eines Treibers, wie z.B. \texttt{init} oder \texttt{mypci\_probe}, auch Funktionen zur Speicherverwaltung. Das Listing \ref{modzpu_functions} zeigt die Deklaration der Funktionen aus der \texttt{modzpu.h}.

\begin{lstlisting}[language=C,firstnumber=47, label=modzpu_functions,caption=Funktionsüberblick des Treibermoduls, float=btp]
// driver specific init and exit functions
static int  __init init    (void);
static void __exit cleanup (void);

// PCI functions
static int  mypci_probe  (struct pci_dev *dev, const struct pci_device_id *id);
static void mypci_remove (struct pci_dev *dev);

// Character device  functions
static int     mychr_open  (struct inode* inodep, struct file* filep);
static int     mychr_close (struct inode* inodep, struct file* filep);
static int     mychr_mmap  (struct file *filep, struct vm_area_struct *vma);
static int     mychr_ioctl (struct inode *inodep, struct file* filep, unsigned int cmd, unsigned long param);
static ssize_t mychr_write (struct file *filep, const char __user *data, size_t count, loff_t *offset);
static ssize_t mychr_read  (struct file *filep, char __user *data, size_t count, loff_t *offset);

// Memory management functions
void myvma_open  (struct vm_area_struct *vma);
void myvma_close (struct vm_area_struct *vma);

// Interrupt function
irqreturn_t myirq_handler(int irq, void *dev_id);
\end{lstlisting}

\subsubsection{Konstanten}

Der Treiber deklariert neben den Funktionen auch benötigte und hilfreiche Konstanten. Zum Beispiel werden die 
\begin{lstlisting}[language=C, firstnumber=13,label=modzpu_constants, caption=Verwendete Konstanten im Treibermodul, float=btp]
#define MINOR_COUNT 1
#define MINOR_FIRST 0

#define VENDOR_ID 0x10EE
#define DEVICE_ID 0x0100

#define ADDR_RAM     0x0000000
#define ADDR_SYSCTL  0x0002000
#define ADDR_DATA    0x0002010
#define ADDR_CONTROL 0x0002014
#define ADDR_STATUS  0x0002018

#define SYSCTL_STOP  0x01
#define SYSCTL_START 0x00

#define CTRL_RXIE    (1 << 1)
#define CTRL_TXIE    (1     )
#define CTRL_STDIN_READY  CTRL_TXIE
#define CTRL_STDOUT_READY CTRL_RXIE

#define STAT_RXINT   (1 << 3)
#define STAT_TXINT   (1 << 2)
#define STAT_RXV     (1 << 1)
#define STAT_TXE     (1     )
#define STAT_STDIN_READY  STAT_TXINT
#define STAT_STDOUT_READY STAT_RXINT

#define ZPU_IO_BUFFER_SIZE 4096
#define ZPU_RAM_SIZE 8192
\end{lstlisting}


\subsubsection{Strukturen}
Weiterhin werden in der \texttt{modzpu.h} Strukturen für Dateioperationen und zur Speicherverwaltung deklariert. Das Listing \ref{modzpu_structures} zeigt dessen Deklaration. Der Struktur für Dateioperationen werden die in Listing \ref{modzpu_functions} deklarierten Gerätefunktionen übergeben. Die Sturktur wird benötigt um Methoden des Treibers beim Registrieren des Geräts mit dem System bekannt zu machen. 

\begin{lstlisting}[language=C, firstnumber=69, label=modzpu_structures,caption=modzpu Strukturen, float=btp]
struct file_operations mychr_fops = {
	.owner   = THIS_MODULE,
	.open    = mychr_open,
	.release = mychr_close,
	.read    = mychr_read,
	.write   = mychr_write,
	.mmap    = mychr_mmap,
	.ioctl   = mychr_ioctl
};

static struct vm_operations_struct myvma_ops = {
	.open = myvma_open,
	.close = myvma_close
};

\end{lstlisting}


\subsection{Initialisieren des Moduls}

Wie im Listing \ref{modzpu_functions} zu sehen ist, wird die Initialisierungsfunktion in der \textit{modzpu.h} deklariert und in der \textit{modzpu.c} implementiert. Das Listing \ref{modzpu_initfunc} zeigt die Implementierung der \textit{init}-Funktion.

\begin{lstlisting}[language=C, firstnumber=67, label=modzpu_initfunc, caption=modzpu Init-Funktion][h!]
static int __init init(void)
{
	int r;
	struct pci_driver *d = &(mypci_driver);

	d->name     = "zpu";
	d->id_table = (const struct pci_device_id*) &(id_table);
	d->probe    = mypci_probe;
	d->remove   = mypci_remove;

	if ((r = pci_register_driver(d)) != 0)
	{
		OUT_WARN("Could not register ZPU device driver.\n");
		return r;
	}

	OUT_DBG("Initialized module.\n");

	return 0;
}
\end{lstlisting}

Benötige Treiberinformationen werden in der Struktur \textit{mypci\_driver} gehalten. Die Struktur ist in \textit{linux/pci.h} deklariert und wird zur Registrierung der PCI-Hardware im Kernel benötigt.\footnote{Vgl. \cite{script_hwstp}, Seite 253}
 
Zur Fehlersicherung wird der Rückgabewert der Funktion \texttt{pci\_register\_driver(d)} überprüft und ggf. wird der Wert, sollte er nicht 0 sein, zurückgeliefert. 

\subsection{Initialisierung des PCI-Geräts}
\label{modzpu_init}

Die eigentliche Initialisierung des PCI-Geräts erfolgt in der Methode \texttt{mypci\_probe}. Diese wurde zuvor in der Initialisierungsmethode registriert und wird vom Kernel aufgerufen, sobald ein entsprechendes Gerät erkannt wurde.

Die \texttt{mypci\_probe}-Methode übernimmt die folgenden Aufgaben:

\begin{enumerate}
	\item Aktivieren des Geräts per \texttt{pci\_enable\_device}.
	\item Abbilden des Gerätespeichers in den Adressraum des Kernels. Hierzu werden zunächst mit \texttt{pci\_resource\_start} und \texttt{pci\_resource\_len} physikalische Adresse und Größe des Gerätespeichers ermittelt. Anschließend wird per \texttt{pci\_request\_regions} Zugriff auf den Bereich angefordert und dieser anschließend per \texttt{ioremap} in den Adressraum des Kernels abgebildet.
	\item Erstellen eines \textit{Character Device} mit dem Namen \textit{zpu} per \texttt{alloc\_chrdev\_region}, \texttt{cdev\_init} und \texttt{cdev\_add}.
	\item Initialisierung zweier FIFO-Speicher, die zum Puffern der Ein- und Ausgabeströme der ZPU dienen. Die Größe der Ein- und Ausgabepuffer wird von der Konstante \texttt{ZPU\_IO\_BUFFER\_SIZE} bestimmt.
	\item Ermittlung der zugehörigen Interrupt-Nummer (diese wird bei PCI-Geräten vom Kernel automatisch erkannt)\footnote{Vgl. \cite{script_hwstp}, Sete 235 ff.} und Registrierung eines Interrupt-Handlers.
	\item Freigabe des \textit{stdout}-Interrupts durch Setzen der entsprechenden Register im Gerätespeicher.
\end{enumerate}

Sollte es beim Ablauf dieser Funktion zu Fehlern kommen, werden bisher durchgeführte Aktionen wieder rückgängig gemacht, damit das System auch beim Fehlerfall in einem konsistenten Zustand hinterlassen wird.

\subsection{IOCTRL}

Um die ZPU in den Reset-Modus versetzen zu können, werden zwei \textit{ioctrl}-Kommandos angeboten: \texttt{RAGGED\_ZPU\_STOP} versetzt die ZPU in den Reset-Modus und \texttt{RAGGED\_ZPU\_START} lässt die ZPU weiterlaufen. Beide Kommandos setzen das RST-Register an Adresse \texttt{0x2000} auf jeweils 1 oder 0. Sie werden später benötigt, um neue Software in den ZPU-Speicher laden zu können.

\subsection{Lese- und Schreibzugriffe}

\begin{figure}
	\begin{center}
		%include from external
		\include{snippets/zpuIO}
		\caption{ZPU-Ein und Ausgabe}
		\label{zpu_io}
	\end{center}
\end{figure}

Die Lese- und Schreibzugriffe auf, bzw. von der ZPU, sind in Abbildung \ref{zpu_io} veranschaulicht. Das Treibermodul kann aus dem Kernel Daten über das Eingabe-FIFO schreiben und über das Ausgabe-FIFO Daten von der PCI-Hardware entgegen nehmen.

\subsubsection{FIFO}

Daten eines FIFOs werden über eine FIFO-Struktur gehalten, welche in der Datei \texttt{fifo.c} implementiert ist. Nachfolgend werden die Funktionen und Makros der \texttt{fifo.c} kurz vorgestellt:

\begin{description}
    \item[void fifo\_init       (fifo\_t *f, size\_t s);]
    In der Initiierungsfunktion werden die Lese- und Schriebzeiger, sowie Queues initialisiert. Ausserdem wird Speicher für Daten per \texttt{vmalloc} alloziiert. 
    
    \item[void fifo\_delete     (fifo\_t *f);]
    Gibt reservierten Speicher wieder frei. 
    
    \item[int  fifo\_transfer   (fifo\_t *f1, fifo\_t *f2, int n);]
    Überträgt $n$ Bytes von dem übergebenen FIFO f1 zu FIFO f2.
    
    \item[u8   fifo\_read\_byte  (fifo\_t *f);]
    Wenn der übergebene FIFO nicht leer ist, wird ein Byte aus dem FIFO gelesen und der Füllstand verringert. 
    
    \item[void fifo\_write\_byte (fifo\_t *f, u8 b);]
    Wenn der übergebene FIFO nicht voll ist, wird ein Byte in das FIFO geschrieben und der Füllstand erhöht.
    \item [bool FIFO\_(NOT\_)FULL(fifo\_t *f)] Wahr, wenn das FIFO (nicht) voll ist
    \item [bool FIFO\_(NOT\_)EMPTY(fifo\_t *f)] Wahr, wenn das FIFO (nicht) leer list.
    \item [int FIFO\_FREE(fifo\_t *f)] Liefert die Anzahl der noch verfügbaren Bytes zurück.
\end{description}

\subsection{Modul-Cleanup}

Das Entfernen des PCI-Geräts wird in der Methode \texttt{mypci\_remove} vorgenommen. Hier werden die bei der Initialisierung durchgeführten Schritte (siehe Abschnitt \ref{modzpu_init}) in umgekehrter Reihenfolge wieder rückgängig gemacht.

Beim Entladen des Kernel-Moduls wird schließlich noch die Methode \texttt{cleanup} aufgerufen. Diese entlädt noch den PCI-Treiber selbst aus dem Kernel.

\begin{lstlisting}[language=C, firstnumber=179, label=modzpu_cleanupfunc, caption=Entfernen des PCI-Geräts, float=btp]
static void mypci_remove(struct pci_dev *dev)
{
	// Free interrupt handler
	free_irq(dev->irq, pcidev_config);

	// Unmap PCI address mapping
	iounmap(pcidev_config);
	pci_release_regions(dev);

	// Disable PCI device
	pci_disable_device(dev);

	// Disable and deallocate character devices.
	cdev_del(&c_dev);
	unregister_chrdev_region(dev_number, MINOR_COUNT);
}
\end{lstlisting}

\subsection{Speicher-Mapping}

Um aus dem Userspace heraus neue Programme in den Speicher der ZPU laden zu können, bietet das Kernelmodul den \texttt{mmap}-Systemaufruf an. Dieser blendet den 8 KiB großen RAM des ZPU-Boards in den Adressraum eines Benutzer-Prozesses ein. Hierzu wird die Methode \texttt{io\_remap\_pfn\_range} genutzt (siehe Listing \ref{modzpu_mmap}).

\begin{lstlisting}[language=C, firstnumber=9, label=modzpu_mmap, caption=Implementierung der mmap-Funktion,float=btp]
static int mychr_mmap(struct file *filep, struct vm_area_struct *vma)
{
	unsigned long vm_size, map_size;

	vm_size  = vma->vm_end - vma->vm_start;
	map_size = vm_size < ZPU_RAM_SIZE ? vm_size : ZPU_RAM_SIZE;
	
	if (io_remap_pfn_range(vma, vma->vm_start,  (paddr + ADDR_RAM) >> PAGE_SHIFT,  map_size,  vma->vm_page_prot) != 0) return -EAGAIN;

	vma->vm_ops = &myvma_ops;
	myvma_open(vma);

	return 0;
}
\end{lstlisting}

\subsection{Interrupt-Bearbeitung}

Die Bearbeitung von Interrupts erfolgt in der Methode \texttt{myirq\_handler}. Da über den Interrupt-Controller mehrere Interrupts ausgelöst werden können, muss hier anhand der Statusregister TXINT und RXINT zunächst überprüft werden, welcher Interrupt-Typ vorliegt.

Der TXINT-Interrupt wird ausgelöst, sobald Daten in den Eingabe-FIFO der ZPU geschrieben werden können. Der RXINT-Interrupt hingegen wird ausgelöst, sobald Daten aus dem Ausgabe-FIFO der ZPU gelesen werden können.

Tritt der TXINT-Interrupt auf, versucht der Interrupt-Handler so viele Bytes wie möglich aus dem Kernel-Puffer in den Eingabe-FIFO der ZPU zu kopieren. Das Kopieren erfolgt byteweise; nach jedem Byte wird anhand des TXE-Registers überprüft, ob noch ein weiteres Byte geschrieben werden kann.

Beim RXINT-Interrupt wird analog dazu verfahren. Hier versucht der Interrupt-Handler, möglichst viele Bytes aus dem Ausgabe-FIFO der ZPU in den Puffer im Kernelspace zu kopieren. Hier wird anhand des RXE-Registers überprüft, ob noch weitere Daten gelesen werden können.

Nachdem so viele Daten wie möglich kopiert wurden, werden am Ende des Interrupt-Handlers eventuell wartende Lese- oder Schreibprozesse (je nachdem, welcher Interrupt aufgetreten ist) wieder aufgeweckt.

\begin{lstlisting}[language=C, firstnumber=12, label=modzpu_irqh, caption=Implementierung des Interrupt-Handlers,float=btp]
irqreturn_t myirq_handler(int irq, void *dev_id)
{
	unsigned int status = ZPU_IO_READ(ADDR_STATUS);
	if ((status & STAT_STDIN_READY) > 0)
	{
		fifo_t *f = &(zpu_io_stdin);
		while ((status & STAT_STDIN_READY) > 0 && FIFO_NOT_EMPTY(f))
		{
			ZPU_IO_WRITE(ADDR_DATA, fifo_read_byte(f));
			udelay(75);
			status = ZPU_IO_READ(ADDR_STATUS);
		}
		
		if (FIFO_EMPTY(f)) ZPU_DISABLE_STDIN_IR();
		
		wake_up_all(&(f->queue));
		return IRQ_HANDLED;
	}
	else if ((status & STAT_STDOUT_READY) > 0)
	{
		fifo_t *f = &(zpu_io_stdout);
		while ((status & STAT_STDOUT_READY) > 0 && FIFO_NOT_FULL(f))
		{
			fifo_write_byte(f, ZPU_IO_READ(ADDR_DATA));
			udelay(75);
			status = ZPU_IO_READ(ADDR_STATUS);
		}
		
		if (FIFO_FULL(f)) ZPU_DISABLE_STDOUT_IR();
		
		wake_up_all(&(f->queue));
		return IRQ_HANDLED;
	}
	return IRQ_NONE;
}
\end{lstlisting}

\pagebreak
\section{Parsing der Intel HEX-Dateien: Die libcintelhex}
\label{chapter_libcintelhex}

Die Logik zum Parsen der Intel HEX-formatierten Eingabedateien wurde in eine eigene Programmbibliothek ausgegliedert. Der folgende Abschnitt beschreibt zunächst das Intel HEX-Datenformat, erläutert anschließend Installation und Schnittstellen der (im Rahmen dieser Arbeit entstandenen) cintelhex-Bibliothek und erklärt die dort verwendeten Algorithmen.

\subsection{Das Intel HEX-Format}

Bei dem \emph{INTEL Hexadecimal Object File Format} (kurz \emph{INTEL HEX}) handelt es sich um ein Dateiformat zur Codierung binärer Daten in ASCII-Dateien. Ursprünglich ausgelegt für 8-Bit-Intelprozessoren mit Adressräumen von 16 Bit, wurde das Format später erweitert für 16-Bit-Prozessoren mit 20-Bit-Adressräumen und für 32-Bit-Prozessoren.
\footnote{Vgl. \cite[S. 4]{intelhex}}

Der Aufbau eines Intel HEX-Datensatzes ist in Abbildung \ref{record_structure} dargestellt. Listing \ref{ihex_example} zeigt einen Auszug aus einer Beispiel-Datei. Jeder Datensatz beginnt mit einem \emph{Record Mark} (ein \texttt{:}-Zeichen, oder \texttt{0x3A} in ASCII). Es folgen die Länge des Datensatzes (1 Byte, codiert in 2 ASCII-Zeichen), der Adress-Offset (2 Byte), der Typ des Datensatzes (1 Byte), der eigentliche Datensatz (variabel, bis zu 255 Bytes) und eine Prüfsumme (1 Byte), anhand derer die Korrektheit des Datensatzes überprüft werden kann.

\begin{figure}[h!]
\begin{center}
\begin{tabular}{cccccc}
	\toprule
	\texttt{:} & \texttt{10} & \texttt{0400} & \texttt{00} & \texttt{B0B0B98B02D0B0B0B88800400000000} & \texttt{29} \\ \midrule
	& Länge & Adresse & Typ & Daten & Prüfsumme \\ \bottomrule
\end{tabular}
\caption{Aufbau eines Intel HEX-Datensatzes}
\label{record_structure}
\end{center}
\end{figure}

Neben regulären Datensätzen (Typ \texttt{0x00}) und einem EOF-Datensatz (Typ \texttt{0x01}), der das Dateiende markiert, kennt die Spezifikation noch weitere Datensatz-Typen, die beispielsweise die Nutzung eines 20- oder 32-Bit-Adressraums ermöglichen. So kann beispielsweise ein spezieller \emph{Extended Linear Address Record} (Typ \texttt{0x04}) verwendet werden, um durch Angabe einer \emph{Upper Linear Base Address} den Adressraum auf 32 Bit zu erweitern.

Da der Speicher des verwendeten ZPU-Boards nur 8 KiB umfasst, ist eine Verwendung der 32-Bit-Funktionen nicht notwendig (16 Bit adressieren maximal $2^{16} = 64$ KiB). Aus diesem Grund bietet die cintelhex-Bibliothek nur experimentelle Unterstützung für 32-Bit-Adressen.

\begin{lstlisting}[caption=Beispiel einer Intel HEX-Eingabedatei,float=bpt,label=ihex_example]
:1000000000000000000000000000000000000000F0
:0400100000000000EC
:100400000B0B0B98B02D0B0B0B8880040000000029
:1004100000000000000000000000000000000000DC
// ...
:1010E200000008D9000008D9000008D9000008D97A
:1010F200000008D9000008D9000008D9000008D96A
:0C110200000008D9000008D9000008D93E
:0400000300000400F5
:00000001FF
\end{lstlisting}

\subsection{Installation}

Die Installation der cintelhex-Bibliothek erfolgt mit den Unix-üblichen \texttt{configure}- und \texttt{make}-Befehlen. Außer dem Build-Tool \texttt{make}, der C-Standardbibliothek und dem GCC werden keine Abhängigkeiten benötigt. Bei der Installation wird die Datei \texttt{libcintelhex.so} nach \texttt{<prefix>/lib}, und die Datei \texttt{cintelhex.h} nach \texttt{<prefix>/include} installiert. Das Standardpräfix ist \texttt{/usr/local}.

\begin{lstlisting}[caption=Installation der cintelhex-Bibliothek]
> ./configure # optional: --prefix=/usr/local
> make
> make install
> ldconfig
\end{lstlisting}

Bei Verwendung des Standardpräfix kann die cintelhex-Bibliothek beim Linken durch den GCC-Parameter \texttt{-l cintelhex} aktiviert werden.

\subsection{Schnittstellenbeschreibung}

Die Methoden der cintelhex-Bibliothek können durch inkludieren der Header-Datei \texttt{cintelhex.h} verwendet werden. In der Datei werden folgende wichtigen Methoden deklariert:

\begin{description}[style=unboxed]
	\item[ihex\_recordset\_t* ihex\_rs\_from\_file(char* filename)] Diese Methode liest den Inhalt einer Intel HEX-Datei (der Dateiname wird durch \texttt{filename} beschrieben) in eine \texttt{ihex\_recordset\_t}-Struktur (siehe auch Abschnitt \ref{ihex_structs}). Sie liefert einen Zeiger auf die ausgelesene Struktur zurück, oder \texttt{NULL} im Fehlerfall.
	\item[ihex\_recordset\_t* ihex\_rs\_from\_string(char* data)] Diese Methode verhält sich genau wie \texttt{ihex\_rs\_from\_file}, erwartet als Eingabeparameter jedoch direkt einen Zeiger auf einen Intel HEX-String.
	\item[int ihex\_mem\_copy(ihex\_recordset\_t *rs, void* dst, ulong\_t n, ihex\_width\_t w, ihex\_byteorder\_t o)] Diese Methode kopiert das durch eine Intel HEX-Datei beschriebene Programm an eine beliebige Stelle im Speicher. Das zu ladende Programm wird durch die Struktur \texttt{rs} beschrieben. Der Zeiger \texttt{dst} beschreibt die Zielposition im Speicher (dies kann auch ein durch \texttt{mmap} abgebildeter Gerätespeicher sein). \texttt{n} beschreibt die Größe des Zielbereichs. Die Methode liefert im Erfolgsfall 0, ansonsten einen Fehlercode zurück.
	\item[char* ihex\_error()] Diese Methode liefert eine Beschreibung des zuletzt aufgetretenen Fehlers zurück. Falls kein Fehler aufgetreten ist, wird \texttt{NULL} zurückgeliefert.
	\item[ihex\_error\_t ihex\_errno()] Diese Methode liefert den Fehlercode des zuletzt aufgetretenen Fehlers zurück. Falls kein Fehler aufgetreten ist, wird \texttt{0} zurückgeliefert.
\end{description}

\subsection{Datenstrukturen}
\label{ihex_structs}

Die cintelhex-Bibliothek definiert die beiden Datenstrukturen \texttt{ihex\_recordset\_t} und \texttt{ihex\_record\_t}. Sie sind wie folgt definiert:

\begin{lstlisting}[language=C,morekeywords={uint\_t, ihex\_rtype\_t, ihex\_addr\_t, ihex\_rdata\_t, ihex\_rchks\_t, ihex\_record\_t, ihex\_recordset\_t}, caption=Definition der \texttt{ihex\_record\_t}- und \texttt{ihex\_recordset\_t}-Strukturen]
/// Models a single Intel HEX record.
typedef struct ihex_record {
	uint_t       ihr_length;   //!< Length of the record in bytes.
	ihex_rtype_t ihr_type;     //!< Record type (see ihex_rtype_t).
	ihex_addr_t  ihr_address;  //!< Base address offset.
	ihex_rdata_t ihr_data;     //!< Record data.
	ihex_rchks_t ihr_checksum; //!< The record's checksum.
} ihex_record_t;

/// Models a set of Intel HEX records.
typedef struct ihex_recordset {
	uint_t         ihrs_count;   //!< Amount of records.
	ihex_record_t *ihrs_records; //!< A list of record (with ihrs_count elements).
} ihex_recordset_t;
\end{lstlisting}

Abbildung \ref{lcih_datastructs} zeigt zudem die Beziehungen der Datenstrukturen untereinander. Das Attribut \texttt{ihex\_data} der Struktur \texttt{ihex\_record\_t} ist ein Zeiger auf ein \texttt{uint8\_t}-Feld der Länge \texttt{ihr\_length}.

\begin{figure}[!htb]
	%include from externl
	\begin{center}
		\include{snippets/libcintelhex_datastructs}
	\end{center}
	\caption{Datenstrukturen der libcintelhex}
	\label{lcih_datastructs}
\end{figure}

\subsection{Fehlercodes}

Die \texttt{cintelhex.h} definiert die folgenden Fehlerkonstanten:

\begin{description}
	\item[IHEX\_ERR\_INCORRECT\_CHECKSUM] Tritt auf, wenn die Prüfsumme eines Eintrages ungültig ist. Zur Verifizierung der Prüfsumme werden alle Bytes eines Eintrages (einschließlich der Prüfsumme selbst) aufsummiert. Ist das unterste Byte der Summe $=0$, ist die Prüfsumme korrekt.
	\item[IHEX\_ERR\_NO\_EOF] Tritt auf, wenn die Eingabedatei keinen EOF-Eintrag (Typ \texttt{0x01}) enthält.
	\item[IHEX\_ERR\_PARSE\_ERROR] Tritt auf, wenn die Eingabedatei ungültig formatiert ist (etwa bei Fehlen des Record Marks (\texttt{:})).
	\item[IHEX\_ERR\_WRONG\_RECORD\_LENGTH] Tritt auf, wenn die tatsächliche Länge eines Datensatzes nicht der im ersten Byte angegebenen entspricht.
	\item[IHEX\_ERR\_NO\_INPUT] Tritt auf, wenn die Eingabedatei nicht existiert, oder nicht geöffnet werden konnte.
	\item[IHEX\_ERR\_UNKNOWN\_RECORD\_TYPE] Tritt auf, wenn ein Datensatz eine ungültige Typ-Bezeichnung (Byte 4) hat).
	\item[IHEX\_ERR\_PREMATURE\_EOF] Tritt auf, wenn der EOF-Datensatz (Typ \texttt{0x01}) in einer anderen Zeile als der letzten auftritt.
	\item[IHEX\_ERR\_ADDRESS\_OUT\_OF\_RANGE] Tritt auf, wenn an eine ungültige Adresse geschrieben werden soll.
	\item[IHEX\_ERR\_MMAP\_FAILED] Tritt auf, wenn eine Eingabedatei nicht in den Speicher gemappt werden konnte.
\end{description}

\subsection{Anwendungsbeispiel}

Listing \ref{cintelhex-example} zeigt ein einfaches Anwendungsbeispiel der cintelhex-Bibliothek. Der Einfachheit halber zeigt die Variable \texttt{d} hier nur auf einen dynamisch alloziierten Speicherbereich, könnte jedoch auch ebenso gut auf den per \texttt{mmap} abgebildeten Speicher des ZPU-Boards zeigen.

\begin{lstlisting}[language=C,caption=Anwendungsbeispiel der cintelhex-Bibliothek,label=cintelhex-example,float=bpt]
#include <stdlib.h>
#include <cintelhex.h>

int main()
{
	ihex_recordset_t* r = ihex_rs_from_file("input.hex");
	void*             d = malloc(8192);
	
	if (r != NULL)
	{
		return ihex_mem_copy(r, d, 8192, IHEX_WIDTH_32BIT, IHEX_ORDER_BIGENDIAN);
	}
	return ihex_errno();
}
\end{lstlisting}

\subsection{Besonderheiten der Umsetzung}

Erste Versionen der cintelhex-Bibliothek versuchten, den Zielspeicherbereits byteweise zu befüllen. Während dies bei Tests an dynamisch alloziiertem RAM kein Problem darstellte, wurde schnell deutlich, dass diese Art des Zugriffs bei dem Speicher des ZPU-Boards nicht funktioniert. Listings \ref{zpu_mem_8bit} und \ref{zpu_mem_32bit} verdeutlichen das Problem.

\begin{lstlisting}[float=p,language=C,caption=Unerwartetes Verhalten des ZPU-Speichers bei 8-Bit-Zugriff,morekeywords={uint8_t,uint32_t},label=zpu_mem_8bit]
uint8_t *d; // d zeigt auf den gemappten Geraetespeicher

d[0x00] = 0x0b;
printf("%02x \n", d[0x00]); // Gibt "0b" aus (korrekt).

d[0x01] = 0x98;
printf("%02x \n", d[0x00]); // Gibt "00" aus (sollte immer noch "0b" sein)!
printf("%02x \n", d[0x01]); // Gibt "98" aus (korrekt).
\end{lstlisting}

\begin{lstlisting}[float=p,language=C,caption=Korrektes Verhalten des ZPU-Speichers bei 32-Bit-Zugriff,morekeywords={uint8_t,uint32_t},label=zpu_mem_32bit]
uint8_t *d; // d zeigt auf den gemappten Geraetespeicher

*((uint32_t*) d) = 0x0000980b;

printf("%02x \n", d[0x00]); // Gibt "0b" aus (korrekt).
printf("%02x \n", d[0x01]); // Gibt "98" aus (korrekt).
\end{lstlisting}

Weiterhin fiel auf, dass das geladene Programm von der ZPU nur dann korrekt ausgeführt werden konnte, wenn die Intel HEX-Daten als 32-Bit-Blöcke in \emph{Big Endian}-Reihenfolge interpretiert wurden. Abbildung  \ref{zpu_addresses} verdeutlicht diesen Zusammenhang.

Die cintelhex-Bibliothek berücksichtigt diesen Zusammenhang. So akzeptiert die Methode \texttt{ihex\_mem\_copy} einen Parameter \texttt{w}, über welchen die Wortbreite angegeben werden kann, sowie einen Parameter \texttt{o}, welcher die Byte-Reihenfolge beschreibt. Listing \ref{ihex_copy_algo} beschreibt den Algorithmus zum Laden eines Intel HEX-Datensatzes in den ZPU-Speicher.

\begin{figure}
\begin{center}
\begin{tabular}{lrrrrrrrrc}
	\toprule
	Daten   &  0B &  0B &  0B &  98 &  B0 &  2D &  0B &  0B & $\ldots$ \\ \midrule
	Adresse & 403 & 402 & 401 & 400 & 407 & 406 & 405 & 404 & $\ldots$ \\ \bottomrule
\end{tabular}
\end{center}
\caption{Übersetzung von Binärdaten in lauffähige ZPU-Programme.}
\label{zpu_addresses}
\end{figure}

\begin{lstlisting}[float=p,language=C,caption=Algorithmus zum Laden eines Intel HEX-Datensatzes in den ZPU-Speicher,morekeywords={uint8_t, uint32_t, ihex_width_t, ihex_record_t, ihex_byteorder_t},label=ihex_copy_algo]
ihex_width_t     w = IHEX_WIDTH_32BIT;     //<! Wortbreite in Byte
ihex_byteorder_t o = IHEX_ORDER_BIGENDIAN; //<! Byte-Reihenfolge
uint8_t          j, l;                     //<! Laufvariablen
ihex_record_t   *x;                        //<! Ein IHEX-Datensatz

for (j = 0; j < x->ihr_length; j += w)
{
	uint32_t  v      = 0;
	uint32_t *target = (uint32_t*) (d + address + j);
					
	for (l = 0; (l < w) && (j + l < x->ihr_length); l ++)
	{
		v += x->ihr_data[j+l] << (8 * ((o == IHEX_ORDER_BIGENDIAN) ? ((w - 1) - l) : l));
	}
	*(target) = v;
}
\end{lstlisting}

\pagebreak
\section{Programmierung der ZPU: Die libzpu}
\label{chapter_libzpu}
Die \textit{libzpu} stellt die für Anwenderprogramme benötigten Funktionen des Treibers zur Verfügung. Die Schnittstelle wurde zur Abstrahierung der Logik für Anwenderprogramme erstellt. Dieser Abschnitt beschreibt die Bibliotheksfunktionen der zpulib. Anwendungsbeispiele finden sich im Abschnitt \ref{chapter_anwenderprogramme}. 

Die Quelltexte für die Bibliothek finden sich auf dem beigelegten Datenträger oder aber auf Github: \url{https://github.com/olivererxleben/zpulib}. 

\subsection{Installation}
Um die Bibliothek auf einem Linux-System zu installieren muss in das Wurzelverzeichnis der Quellen gewechselt werden und dort über ein Unix-übliches Makefile ausgeführt werden.

\begin{lstlisting}[language=bash,caption=Installation der zpulib-Bibliothek]
# in directory
> ./configure
> make
> make install
\end{lstlisting}

\subsection{Typdefinitionen und Variablen}

Die zpulib verwendet zur Fehlerbehandlung und für Funktionsrückgaben zwei eigene Typen und zwei globale Variablen. Das Listing \ref{zpulib_types_vars} zeigt dessen Deklaration in der zpu.h.

\begin{lstlisting}[language=C,firstnumber=28,caption=zpulib Typen und Variblen,label=zpulib_types_vars]
// TYPE DEFINITIONS

typedef unsigned int uint_t;
typedef uint_t       zpu_error_t;

// GLOBAL VARIABLES

#ifdef ZPU_C
static zpu_error_t zpu_last_errno = 0;
static char*       zpu_last_error = NULL;
#else
extern zpu_error_t zpu_last_errno; //!< Error code of last error.
extern char*       zpu_last_error; //!< Description of last error.
#endif

\end{lstlisting}

\texttt{zpu\_error\_t} wird beispielsweise als Rückgabetyp von der Funktion \texttt{zpu\_load\_from\_file} verwendet. 

\subsection{Schnittstellenbeschreibung}
Die Methoden der libzpu können durch das Inkludieren der \texttt{zpu.h} in ein Anwenderprogramm benutzt werden. Die \textit{zpulib} benutzt zudem Funktionen der \textit{libcintelhex} um Hex-Dateien zu laden. Nachfolgend werden die Funktionen der zpulib beschrieben.

\begin{description}[style=unboxed]
	\item[zpu\_error\_t zpu\_load\_from\_file(char* filename);] 
	Die Methode wird verwendet um eine neues Programm in die ZPU zu laden. Vor dem Laden des Programms wird die ZPU in in den sog. \textit{reset}-Modus gesetzt. Erst danach wird das zu ladene Programm von der Intel Hex Bibliothek geparsed und in den ROM der ZPU kopiert. Die Programm-Datei muss vom Typ INTEL Hex sein. 
	
	\item[int zpu\_stop();]
	Versetzt die ZPU in den \textit{reset}-Modus. Liefert \texttt{ZPU\_ERR\_OK} bei Erfolg zurück. Andernfalls einen Error Code. 
	
	\item[int zpu\_start();]
	Versetzt die ZPU aus denm \textit{reset}-Modus in den regulären Betriebszustand zurück. Die Methode liefert \texttt{ZPU\_ERR\_OK} bei Erfolg zurück. Andernfalls einen Error Code.
	
	\item[zpu\_error\_t zpu\_errno();]
	Eine Hilfsmethode zum Debuggen von Anwenderprogrammen. Sie liefert die Nummer des zuletzt aufgetretenen Fehlers zurück. 
	
	\item[char* zpu\_error();]
	Eine Hilfesmethode zum Debuggen von Anwenderprogrammen. Sie liefert den zuletzt aufgetretenen Fehler zurück. 
\end{description}

\subsection{Fehlercodes}
Neben Typen, Variablen und Funktionen definiert die zpulib auch Fehlercodes, welche beim Debugging von Anwenderprogrammen genutzt werden können.  
Folgende Fehlerkonstanten werden in der \texttt{zpu.h} deklariert:
\begin{description}
    \item[\#define ZPU\_ERR\_OK              0x00]
    OK, bzw. 0, wird zurückgegeben wenn kein Fehler aufgetreten ist. 
    
    \item[\#define ZPU\_ERR\_PARSEERROR      0x01]
    Dieser Fehlercode wird von der zpulib zurückgegeben, wenn ein ZPU-Programm von der libchintelhex nicht analysiert werden konnte. 
    
    \item[\#define ZPU\_ERR\_DEVFILEOPEN     0x02]
    Der Fehlercode tritt auf wenn ein ZPU-Programm nicht geöffnet werden konnte. Zum Beispiel wenn die Datei nicht gefunden wurde. 
    
    \item[\#define ZPU\_ERR\_MMAP            0x03]
    Der MMAP-Fehlercode wird zurückgeliefert, wenn das Mapping der ZPU fehlgeschlagen ist. 
    
    \item[\#define ZPU\_ERR\_MEMCOPY         0x04]
    Bei dieser Fehlerkonstanten handelt es sich um den Fehler der beim Kopieren in den RAM der ZPU geschehen kann. 
    
    \item[\#define ZPU\_ERR\_COULDNOTSTOP    0x05]
    Der Fehler wird zurückgegeben wenn die ZPU nicht in den \textit{reset}-Modus versetzt werden konnte.
    
    \item[\#define ZPU\_ERR\_COULDNOTSTART   0x06]
    Wird zurückgegeben, wenn die ZPU nicht aus dem \textit{reset}-Modus zurück in den normalen Betriebszustand versetzt werden konnte. 
    
\end{description}

Anzumerken ist, dass alle Fehlercodes in der Funktionsimplementierung Verwendung finden (siehe weitere Abschnitte). 

\pagebreak
\section{Anwenderprogramme}
\label{chapter_anwenderprogramme}
Zur Steuerung des ZPU-Boards wurden schließlich die Werkzeuge \emph{zpuload}   und \emph{zpuio} entwickelt. Das Paket liegt dieser Arbeit auf Datenträger bei, und befindet sich im Verzeichnis \texttt{apps/zputools}.

\subsection{Installation}

\emph{zpuload} und \emph{zpuio} gehören beide zum \emph{zputools}-Paket, können also gemeinsam installiert werden. Wie bei den anderen im Rahmen dieser Arbeit entstandenen Pakete, reicht auch hier der übliche Dreizeiler zur Installation aus:

\begin{lstlisting}[caption=Installation der zputools-Werkzeuge]
> ./configure # optional mit --prefix=...
> make
> make install
\end{lstlisting}

Bei der Installation werden die ausführbaren Programme \emph{zpuload} und \emph{zpuio} (abhängig vom prefix) nach \texttt{/usr/local/bin} kopiert.

Die \emph{zputools} benötigen einen GCC, die C-Standardbibliothek, sowie eine installierte cintelhex-Bibliothek (siehe Abschnitt \ref{chapter_libcintelhex}) und eine installierte zpu-Bibliothek (siehe Abschnitt \ref{chapter_libzpu}). Das \emph{configure}-Skript überprüft diese Abhängigkeiten automatisch.

\subsection{Programme laden mit zpuload}

Das \emph{zpuload}-Programm verwendet die Funktionen der \emph{cintelhex}- und \emph{zpu}-Bibliotheken, um ein neues Programm in den ZPU-Prozessor zu laden.

Hierzu wird per \texttt{zpu\_load\_from\_file(file)}-Methode ein neues Programm in den RAM der ZPU geladen (diese Methode versetzt die ZPU zuvor implizit in des Reset-Modus und startet sie anschließend wieder).

\begin{lstlisting}[caption=Verwendung des zpuload-Werkzeugs]
> /usr/local/bin/zpuload input.hex
Loading program from "input.hex"...
Loaded program.
\end{lstlisting}

\subsection{Ein- und Ausgabe mit zpuio}

Das \emph{zpuio}-Werkzeug dient dazu, Ein- und Ausgaben an den ZPU-Prozessor zu übermitteln. Dieses Programm ist vor allem als interaktive Schnittstelle gedacht.

\begin{lstlisting}[caption=Verwendung des zpuio-Werkzeugs]
> /usr/local/bin/zpuio
output (11) > Hello World
input > abcd
output (4) > Abcd
input >
\end{lstlisting}

Neben der Verwendung des \emph{zpuio}-Werkzeugs kann auch direkt in/aus der Gerätedatei \emph{/dev/zpu} geschrieben und gelesen werden.

\pagebreak
\section{Fazit}

Mit den im Rahmen dieser Arbeit entwickelten Kernel-Module, Bibliotheken und Anwenderprogramme steht eine einfach benutzbare und gut erweiterbare Toolchain zur Arbeit mit einem ZPU-Board zur Verfügung.

Um die Arbeit mit diesen Werkzeugen weiter zu vereinfachen, wäre in einer fortführenden Arbeit beispielsweise möglich, über entsprechende udev-Regeln das Kernelmodul automatisch zu laden, die entsprechenden Gerätedateien zu erstellen. Zudem könnte über eine udev-Regel bereits beim Booten durch einen Aufruf des \textit{zpuload}-Programms eine initiale Firmware in die ZPU geladen werden.

Um die Upgrade-Fähigkeit des Kernel-Moduls über mehrere Kernel-Versionen hinweg sicherzustellen, böte sich zudem die Verwendung des von Dell entwickelten DKMS-Frameworks an.\footnote{Vgl. \cite{dkms-ljournal}.}

\pagebreak % content ends here

\fancyhead[R]{}

\thispagestyle{empty}

\renewcommand*{\biburlprefix}{(URL: }
\renewcommand*{\biburlsuffix}{)}

\pagebreak
\addcontentsline{toc}{section}{Literaturverzeichnis} % Eintrag ins Inhaltsverzeichnis
\bibliography{bib/bib}

\appendix

\end{document}
